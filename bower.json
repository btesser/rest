{
  "name": "nucleus-angular-rest",
  "version": "0.3.2",
  "dependencies": {
    "string-json-parser": "latest"
  },
  "devDependencies": {
    "lodash": "1.2.x",
    "angular": "1.0.6",
    "angular-mocks": "1.0.6",
    "unstable-angular-complete": "1.1.4",
    "jquery": "1.9.x"
  },
  "gitHead": "2cca5e6bd05151f1ef0fe82ba080559d3a089576",
  "readme": "# Nucleus Angular REST\n\nThis component of Nucleus Angular is designed to allow you to easily use a REST API within your AngularJS applications.  There are other libraries that serve a similar purpose to this one and the two I most commonly see referenced are:\n\n* Restangular - https://github.com/mgonto/restangular\n* BreezeJS - http://www.breezejs.com\n\nAn I invite you to have a look at those solutions if this library does not seem to feel like a right fit for you.\n\nIf you want to get into the meet of the documentation, skip to <a href=\"#installation\">Installation</a> or <a href=\"#basic-guide\">Basic Guide</a>.\n\n## LICENSE\n\nMIT\n\n## Why Another Library Then\n\nThis library differs from the libraries I mentioned above in a few ways.\n\nIn contrast to <a href=\"https://github.com/mgonto/restangular\">Restangular</a>, this library provides more structure.  You are able to define models and their attributes.  This opens the library to provide functionality like automatic data validation, dirty field tracking, and so on.\n\nIn contrast to <a href=\"http://www.breezejs.com\">BreezeJS</a>, this library is designed specifically for AngularJS and is designed in such a way that it makes no assumptions to the backend used (I know BreezeJS can be used with any backend however it's roots seem to be .NET/EF). Being designed specifically for AngularJS, this library will be able to do certain things that BreezeJS might not be able to do or at least be able to do in as a cleaner way.  It will also not have functionality that is designed for a specific system (like having Int16, Int32, Int64 data types is probably mainly useful for .NET/EF, diffidently not languages like PHP or Python).  Everything will be at the most generic level in javascript.  Validation based on Int16, Int32, Int64 data types can be done on the REST API where I believe it belongs (since it is not valid for all server side implementations).\n\nAs long your are implementing a RESTish API, this solution should work for you.\n\n## IE 8 Support\n\nOriginally this library was designed to support IE 8 (the 0.2.x series) however a concern relating to the implementation specifically there to support IE 8 was brought up and was a valid concern.  After playing around with a few other implementations that supported IE 8, it was decided to just drop IE 8 support.\n\nThe specific issue was the fact that IE 8 does not support Object.defineProperty()/Object.defineProperties().  Not having these available forces the library to use an methodology that has been somewhat common of doing set(field, value)/get(field) methods to interact with data (as far as I know, even libraries like ExtJS/Sencha do this: http://docs.sencha.com/extjs/4.0.7/#!/api/Ext.data.Model).  While this has worked in the passed and will continue to work in the future for other libraries, doing it like this for an AngularJS library is not the greatest.\n\nWith set()/get() methods, binding a model to say a form is not that straight forward.  The process go something like this:\n\n* Convert the model to a JSON variable\n* Binding the JSON variable to the form\n* $scope.$watch() the JSON variable and syncing the data back to the model when it detects a change\n\nThen you have the issue of making sure any changes to the model that happen through the code are reflect in the form data.\n\nNow that this library is using defineProperties() to expose the model's data as simple properties of the model, we should be able to bind the model directly to the form and let AngularJS do it 2-way binding magic for us.\n\nNot supporting IE 8 also gives us access to other ES5 functionality the IE 9+ does support which will probably make certain things easier in the long run.\n\n# Change Log\n\nEach change log are assumed to be accompanied by associated unit test and documentation updates.\n\n## 0.3.0\n\n* IE 8 support dropped\n* Completely rewrote the foundation for models/repositories (backward compatible broken)\n* Karma configuration file update (phantom configurations now include code coverage)\n* Flatten url logic now accounts for the base url\n* Added strict mode configuration though not being used anywhere yet\n\n## 0.2.3\n\n* Config values are now using a provider that can be configured in a module.config() instead of using .values()\n* Added logic for flattenItemRoute property in schema definition for better support when using model.getRelation()\n* Added logic for flatten for property are part of relation config in schema definition for better support when using model.getRelation()\n* Added Karma configuration files for PhantomJS\n\n## 0.2.2\n\n* Added logic for isArray property in schema definition\n* Added forceIsArray to model/repository instances\n\n## 0.2.1\n\n* Fixed typo where parseData was being used instead parsedData\n* Move lodash into dev dependencies\n\n## 0.2.0\n\n* Initial Commit\n\n# Testing\n\nThere are a suite of unit tests for each thought of use case.  The unit test are execute against both the stable (1.0.6) and unstable (1.1.4) angular branches.  Travis CI use PhantomJS to run it's test but tests are also executed on the following browsers/OSes:\n\n* Chrome (Mac OS X 10.8.x, Windows 7)\n* FireFox (Mac OS X 10.8.x, Window 7)\n* Safari (Mac OS X 10.8.x)\n* Opera (Mac OS X 10.8.x, Windows 7)\n* IE 9 (Windows 7)\n* IE 10 (Windows 7)\n\n# Usage\n\nThis is just basic documentation.  You can probably find out even more by looking at the unit tests and the source code itself.\n\n## NOTE\n\nThis is still in early development and as such, I can't guarantee that backwards breaking compatibility changes won't be made.  There may still be bugs or use cases that don't yet have unit tests but if you find any of those, please submit them to the github issue tracker.\n\n### Pull Requests\n\nTBD\n\n## Installation\n\nInstallation of Nucleus Angular REST is simply done with bower:\n\n```bower install nucleus-angular-rest```\n\n## File Inclusion\n\nThen include the files:\n\n```\n<script type=\"text/javascript\" src=\"/components/string-json-parser/string-json-parser.js\"></script>\n<script type=\"text/javascript\" src=\"/components/nucleus-angular-rest/module.js\"></script>\n<script type=\"text/javascript\" src=\"/components/nucleus-angular-rest/config.js\"></script>\n<script type=\"text/javascript\" src=\"/components/nucleus-angular-rest/schema-manager.js\"></script>\n<script type=\"text/javascript\" src=\"/components/nucleus-angular-rest/model-factory.js\"></script>\n<script type=\"text/javascript\" src=\"/components/nucleus-angular-rest/repository-factory.js\"></script>\n```\n\n### Dev Dependencies\n\nYou will notice 2 different versions of angular and lodash as dev dependencies.  The reason they are set as dev dependencies and not regular dependencies is because I want the user to have the choice of which versions of those libraries to use in production (they are still in the dev dependencies as they are needed to run the unit tests).\n\nJust remember that you will need to include a version of lodash and angular in order for this library to work.\n\n## Including the module\n\nThen finally, include the nag.rest module in your application\n\n```javascript\nangular.module('app', ['nag-rest'])\n//your application code\n```\n\n# Basic Guide\n\nThis is just some basic documentation, hopefully enough to get you starting and running with this library.  If you are confused about anything or want to dig deeper, I encourage you to either dig through the unit tests or even the source code.  I can't tell you how much I have learned about angular or unit testing with angular by digging through their source code and unit tests.\n\nIf you find anything incorrect in the documentation or find something in the code that you think needs to be documented, please submit and issue in the github tracker.\n\n## Querying REST API results\n\nUnless otherwise specifically stated, any method that makes a request to the api for data, whether returning one or multiple records, can be processed in 2 different ways\n\nOne way is by value, as shown by the following:\n\n```javascript\n//in this instance an array will be returned and it will have the data populated once the rest api\n//returns the data and it is processed\nvar arrayResults = repository.mngr.find();\n\n//in this instance an empty model will be returned and it will have the data populated once the rest\n//api returns the data and it is processed\nvar project = user.mngr.getRelation('project', 234);\n```\n\nThe second way is by way of the promise's then() method, as shown by the following:\n\n```javascript\nrepository.mngr.find().then(function(data) {\n  //the data parameter has a few properties associated to it.  if the schema configuration has autoParse\n  //to true (which by default it is) one of them will be parsedData.  in the result of doing a find()\n  //with a string/number, parsedData is a model and when doing .find() with an object, parsedData is an\n  //array\n  users = data.parsedData;\n\n  //another element that is always available is the raw unprocessed JSON of the response as the\n  //rawResponse property.  if you have autoParse set to false then you will have to use the promise\n  //way of getting the data and process the rawResponse manually in the success of the then() method\n  var customResponseProcessor = function(response) {\n    //code...\n  };\n  users = customResponseProcessor(data.rawResponse);\n\n  //another use for the rawResponse is maybe there is some meta data you need, like for instance the\n  //rest api supports paging of data and you need that data for the controller\n  totalRecord; = data.rawResponse.meta.totalRecords;\n});\n\nuser.mngr.getRelation('project', 234).then(function(data) {\n  //the parsedData property will have the model\n  user = data.parsedData;\n\n  //and of course you can do custom processing here too\n  var customResponseProcessor = function(response) {\n    //code...\n  };\n  user = customResponseProcessor(data.rawResponse);\n});\n```\n\nThe rest of the code examples might use either of the options for getting the data depending on the situation.\n\n#### Structuring The Code\n\nThis code example documentation is not structured in any angular code like .service, .factory, .run, etc... however one tip I would give on this subject is that I think it make sense to wrap common use repositories in a config/factory like this:\n\n```javascript\nangular.module('app.models', ['nag.rest'])\n//adding the schema in the .config() will allow it to be available without having to get an instance of\n//the repository\n.config([\n  'nagRestSchemaManager',\n  function(nagRestSchemaManager) {\n    nagRestSchemaManager.add('user', {\n      route: '/users',\n      properties: {\n        id: {\n          sync: false\n        },\n        firstName: {},\n        lastName: {},\n        username: {},\n        email: {}\n      },\n      relations: {\n        project: {\n          route: '/projects'\n        }\n      },\n      dataListLocation: 'response.data.users',\n      dataItemLocation: 'response.data.user'\n    });\n  }\n])\n.factory('userRepository', [\n  'nagRestRepositoryFactory',\n  function(nagRestRepositoryFactory) {\n    var userRepository = nagRestRepositoryFactory.create('user');\n\n    //add custom methods to userRepository as needed\n\n    return userRepository;\n  }\n]);\n```\n\n## Config\n\nThe configuration service allows you to retrieve/configure certain options of this library.  To retrieve the properties, you can the nagRestConfig service which has the following API (they all also have corresponding set methods as shown in the nagRestConfigProvider example):\n\n* getBaseUrl() - Returns the base url (default: '')\n* getResponseDataLocation() - Returns the string representing where the data lives in the response from the rest api (default: '')\n* getModelIdProperty() - Returns the default idProperty for schemas (default: 'id')\n* getUpdateMethod() - Returns the default method used when updating model with the.sync() method (default: 'PUT')\n* getFlattenItemRoute() - Return the value used as the default value for the schema's flattenItemRoute configuration (default: false);\n* getStrictMode() - Used to determine if certain code paths should be executed like throwing certain exceptions, doing extra checking, etc... (default: false);\n* getRequestFormatter() - Returns a function used to format the data before it is sent to the rest api with the model's .sync() method (default: function(){})\n\nYou can set these values using the nagRestConfigProvider service within a .config() like this:\n\n```javascript\nangular.module('app', ['nag.rest'])\n.config([\n  'nagRestConfigProvider',\n  function(nagRestConfigProvider) {\n    nagRestConfigProvider.setBaseUrl('/api');\n    nagRestConfigProvider.setResponseDataLocation('response.data');\n    nagRestConfigProvider.setModelIdProperty('uid');\n    nagRestConfigProvider.setUpdateMethod('PATCH');\n    nagRestConfigProvider.setFlattenItemRoute(true);\n    nagRestConfigProvider.setStrictMode(true);\n    nagRestConfigProvider.setRequestFormatter(function(data) {\n      return {\n        request: {\n          data: data\n        }    \n      };\n    });\n  }\n});\n```\n\n## APIs\n\nA list of the APIs for the components included in this package.  This contains a basic list of methods and parameters with a simple description and a code example for each.\n\n### Schema Manager\n\nThe Schema Manager can be accessed through the nagRestSchemaManager service.  It has the following API:\n\n* add(resourceName, schema) - adds a schema (look at <a href=\"#schema\">schema</a> to see the schema structure)\n\n```javascript\n//------------------------------------------------------------------------------------------------------\n//---- NOTE: the rest of the documentation is going to assume these resources/schemas are available ----\n//------------------------------------------------------------------------------------------------------\nvar userSchema = {\n  route: '/users',\n  properties: {\n    id: {\n      sync: false\n    },\n    firstName: {},\n    lastName: {},\n    username: {},\n    email: {}\n  },\n  relations: {\n    project: {\n      resource: 'team'\n    }\n  },\n  dataListLocation: 'response.data.users',\n  dataItemLocation: 'response.data.user'\n};\n\nprojectSchema = {\n  route: '/projects',\n  properties: {\n    projectId: {\n      sync: false\n    },\n    name: {},\n    creatorId: {}\n  },\n  relations: {\n    team: {\n      resource: 'team'\n    }\n  }\n  idProperty: 'projectId',\n  dataListLocation: 'response.data.projects',\n  dataItemLocation: 'response.data.project',\n  flattenItemRoute: false\n};\n\nteamSchema = {\n  route: '/teams',\n  properties: {\n    id: {\n      sync: false\n    },\n    name: {}\n  },\n  dataListLocation: 'response.data.teams',\n  dataItemLocation: 'response.data.team'\n};\n\n//after this you will be able to pass the string 'user' with anything asking for a resourceName\nnagRestSchemaManager.add('user', userSchema);\n\n//after this you will be able to pass the string 'project' with anything asking for a resourceName\nnagRestSchemaManager.add('project', projectSchema);\n\n//after this you will be able to pass the string 'team' with anything asking for a resourceName\nnagRestSchemaManager.add('team', teamSchema);\n```\n\n* get(resourceName, overrideSchemaOptions) - retrieves a schema\n\n```javascript\nnagRestSchemaManager.add('user', userSchema);\n\n//this will return a copy of the schema that is tied to the 'user' resource.  this copy can be modified\n//without the stored version being effected\n\n// resulting object:\n// {\n//   route: '/users',\n//   properties: {\n//     id: {\n//       sync: false\n//     },\n//     firstName: {},\n//     lastName: {},\n//     username: {},\n//     email: {}\n//   },\n//   relations: {\n//     project: {\n//       resource: 'project'\n//     }\n//   },\n//   dataListLocation: 'response.data.users',\n//   dataItemLocation: 'response.data.user'\n// }\nvar pulledUserSchema = nagRestSchemaManager.get('user');\n\n//you can also pass in a second parameter that will override values in the resulting schema, it will not\n//effect anything stored in the schema manager itself.  it will also override recursively meaning that\n//if you want to override one of the properties, you can do that without effecting the other properties.\n\n// returns:\n// {\n//   route: '/custom/users',\n//   properties: {\n//     id: {\n//       sync: false\n//     },\n//     firstName: {},\n//     lastName: {},\n//     username: {},\n//     email: {\n//       sync: 'create'\n//     }\n//   },\n//   relations: {\n//     project: {\n//       resource: 'project'\n//     },\n//     manager: {\n//       resource: 'user'\n//     }\n//   },\n//   dataListLocation: 'response.data.users',\n//   dataItemLocation: 'response.data.user'\n// }\nvar customUserSchema = nagRestSchemaManager.get('user', {\n  route: '/custom/users',\n  properties: {\n    email: {\n      sync: 'create'\n    }\n  },\n  relations: {\n    manager: {\n      resource: 'user'\n    }\n  }\n});\n```\n\n* remove(resourceName) - removes a schema\n\n```javascript\nnagRestSchemaManager.add('user', userSchema);\n\n//this will remove the schema from the manager\nnagRestSchemaManager.remove('user');\n\n// returns:\n// undefined\nvar pulledUserSchema = nagRestSchemaManager.get('user');\n```\n\n* normalizeData(schema, data, way) - converts the data based on the way which can be either 'incoming' or 'outgoing' (defaults to 'incoming')\n\n```javascript\nvar schema = {\n  route: '/users',\n  properties: {\n    id: {\n      remoteProperty: 'IdenTiFIer'\n    },\n    firstName: {\n      remoteProperty: 'firstname'\n    },\n    lastName: {\n      remoteProperty: 'LAST_NAME'\n    }\n  }\n};\n\n// returns:\n// {\n//   id: 1,\n//   firstName: 'John',\n//   lastName: 'Doe'\n// }\nvar incomingDataNormalized = nagRestSchemaManager.normalizeData(schema, {\n  IdenTiFIer: 1,\n  firstname: 'John',\n  LAST_NAME: 'Doe'\n});\n\n// returns:\n// {\n//   IdenTiFIer: 1,\n//   firstname: 'John',\n//   LAST_NAME: 'Doe'\n// }\nvar outgoingDataNormalized = nagRestSchemaManager.normalizeData(schema, {\n  id: 1,\n  firstName: 'John',\n  lastName: 'Doe'\n}, 'outgoing');\n```\n\n### Repository Factory\n\nThe Repository is the main way to create models and get data from the REST API.  You can create an instance of a Repository by using the nagRestRepositoryFactory service.  That has the following API:\n\n* create(resourceName, overrideSchemaOptions) - returns an instance of a Repository\n\n```javascript\n//all you need to do in order to create a repository is pass in the resourceName that matches the\n//schema you want\nvar userRepository = nagRestRepositoryFactory.create('user');\n\n//there is also a second parameter allowing you to customize the schema for the instance of the\n//repository that is going to be created.  this is useful if there is a specialized rest api, lets\n//say /session, that returns a standard resource\nvar sessionRepository = nagRestRepositoryFactory.create('user', {\n  route: '/session',\n  dataItemLocation: 'response.data',\n  isArray: false\n});\n```\n\n### Repositories\n\nAll the internal properties are exposed through the .mngr property.  This is done so not to pollute the top level properties and makes a clean distinction between built-in properties and custom properties.  The instance of the repository (the result of the nagRestRepositoryFactory.create()) itself has the following API:\n\n* mngr.schema - returns the schema configured for this repository (READ ONLY)\n\n* mngr.resourceName - returns the resource name configured for this repository (READ ONLY)\n\n* mngr.route - return the base route for this repository (READ ONLY)\n\n* mngr.create(initialData, remoteFlag, overrideSchemaOptions) - returns a new empty instance of the model for the repository\n\n```javascript\n//using the repository is the recommended way to generate a new models, the first parameter is the\n//initial data\nvar userRepository = nagRestRepositoryFactory.create('user');\nvar user = userRepository.mngr.create({\n  firstName: 'John',\n  lastName: 'Doe'\n});\n\n//now by default it will create a model that has mngr.state set to 'new' so syncing it will make\n//it attempt a POST.  maybe you are getting data the you know is remote and if so you can give the\n//second parameter a value of true.  just note that you also have to make sure that the idProperty of\n//initial data is also set otherwise is will still assume the model's mngr.state is 'new' even if\n//the second parameter has a value of true\nvar remoteUser = userRepository.mngr.create({\n  id: 123,\n  firstName: 'John',\n  lastName: 'Doe'\n}, true);\n\n//the third parameter will allow you to create an instance of a model with a customized schema.  by\n//default the model generated will use the schema associated to the repository but the third\n//parameter is a list of overrides for the schema for the instance of that model\nvar customUser = userRepository.mngr.create({}, false, {\n  route: '/custom/users'\n});\n```\n\n* mngr.find(params, headers, postData) - makes a request to the REST API to retrieve data\n\n```javascript\n//one method that exists in order to retrieve data from a repository is the find() method.  The first\n//parameter of find can take an object with key/value pairs that will be inserted into the query string\n//part of the url.\n\n// GET /users?firstName=John\nvar users = userRepository.mngr.find({\n  firstName: 'John'\n});\n\n//you can also pass a number/string as the first argument and it will assume that is the value of the\n//idProperty for the data the repository represents.  in this case the result is initially a new empty\n//model and the data gets filled in once the data is received and processed\n\n// GET /users/123\nvar user = userRepository.mngr.find(123);\n\n//The second parameter of find() is an object of header/value pairs\n\n// GET /users with request header x-user:test\nvar users = userRepository.mngr.find({}, {\n  'x-user': 'test'\n});\n\n//now some rest apis offer the ability to do very complex queries however because of the complexity,\n//they require you to pass the data in as a post request instead of get and that is what the third\n//parameter is for.  If the third parameters is an object, it will send the request as a POST with\n//the data of the third parameters as the content body\n\n// POST /users?query=data with content of\n// {\n//   \"filters\": [{\n//     \"field\": \"email\",\n//     \"condition\": \"like\",\n//     \"value\": \"%@gmail.com\"\n//   }]\n// }\nvar gmailUsers = userRepository.mngr.find({\n  query: 'data',\n}, {}, true, {\n  filters: [{\n    field: 'email',\n    condition: 'like',\n    value: '%@gmail.com'\n  }]\n});\n```\n\n* forceIsArray(value) - will assume the next request for retrieving data result will or will not be an array (based on passed value), will override schema.isArray\n\n```javascript\n//now when retrieving data, the library is smarter enough to guess whether the results will be returned\n//as an array or a single object however sometimes the guess will be wrong.  any time you are retrieving\n//data without an id, it assumes an array will be returned and when you have an id, it assume an object\n//will be returned.  now lets say we have a rest api call with the route /session but it returns a\n//single user object.  one way is to use the forceIsArray() method:\n\n// get /session\nvar sessionRepository = nagRestRepositoryFactory.create('user', {\n  '/session'\n});\nsessionRepository.mngr.forceIsArray(false).find();\n```\n\n### Model Factory\n\nThe model is the main way to interact with individual records from the REST API and sync data to the REST API.  It is recommended that you use the repository instance to create instances of a model however you can also create an instance of the model using the nagRestModelFactory service.  It has the following API:\n\n* create(resourceName, data, synced, overrideSchemaOptions) - returns an instance of a Model\n\n```javascript\n//it is not recommend you create models from the nagRestModelFactory (always try to use the\n//repository.mngr.create() method) but if the case does arrive that you need to, the option\n//does exist.  the first parameter is the resourceName that has the schema you want to based\n//this model off of.\nvar user = nagRestModelFactory.create('user');\n\n//the second parameter is the initial data\nvar user nagRestModelFactory.create('user', {\n  firstName: 'John',\n  lastName: 'Doe'\n});\n\n//now by default it will create a model that has mngr.state set to 'new' so syncing it will make\n//it attempt a POST.  maybe you are getting data the you know is remote and if so you can give the\n//third parameter a value of true.  just note that you also have to make sure that the idProperty of\n//initial data is also set otherwise is will still assume the model's mngr.state is 'new' even if\n//the second parameter has a value of true\nvar remoteUser = nagRestModelFactory.create('user', {\n  id: 123,\n  firstName: 'John',\n  lastName: 'Doe'\n}, true);\n\n\n//the fourth parameter will allow you to create an instance of a model with a customized schema.  by\n//default the model generated will use the schema associated to the repository but the third\n//parameter is a list of overrides for the schema for the instance of that model\nvar customUser = nagRestModelFactory.create('user', {}, false, {\n  route: '/custom/users'\n});\n```\n\n### Models\n\nAll the internal properties are exposed through the .mngr property.  This is done so not to pollute the top level properties and makes a clean distinction between built-in properties and custom properties.\n\n#### Properties\n\nProperties configured in the schema for the model are exposed as simple properties of the model object itself:\n\n```javascript\nvar userRepository = nagRestRepositoryFactory.create('user');\nvar user = userRepository.create({\n  id: 1,\n  firstName: 'John';\n  lastName: 'Doe'\n});\n\n// returns:\n// 1\nuser.id;\n\n// returns:\n// 'John'\nuser.firstName;\n\n// returns:\n// 'Doe'\nuser.lastName;\n```\n\nThe instance of the model itself (the results of a repository.mngr.create()) has the following API:\n\n* mngr.state - returns the current state of the model (READ ONLY). Can be the following:\n  * new - The model is not yet sent through the api to be process (generally persistent to some backend)\n  * loaded - The model's data is the latest data that is is aware of\n  * dirty - A very of the model is processed through the API however it has unprocessed changes\n  * deleted - The model has been processed for deletion through the API\n\n```javascript\nvar userRepository = nagRestRepositoryFactory.create('user');\nvar user = userRepository.mngr.create();\n\n// returns:\n// 'new'\nuser.mngr.state;\n\nuser.firstName = 'John';\nuser.lastName = 'Doe';\nuser.mngr.sync();\n\n// returns:\n// 'loaded'\nuser.mngr.state;\n\nuser.firstName = 'John2';\n\n// returns:\n// 'dirty'\nuser.mngr.state;\n\nuser.delete();\n\n// returns:\n// 'deleted'\nuser.mngr.state;\n```\n\n* mngr.dirtyProperties - returns an array of the property names that are dirty (READ ONLY)\n\n```javascript\n\nvar userRepository = nagRestRepositoryFactory.create('user');\nvar user = userRepository.mngr.create();\n\n//since we have not set any data, mngr.dirtyProperties will return an empty array\n\n// returns:\n// []\nuser.mngr.dirtyProperties;\n\nuser.username = 'john.doe';\n\n//now that we have set data that is not synced, we can check that by the mngr.dirtyProperties\n//which will return an with the properties that are dirty\n\n// returns:\n// [\n//   'username'\n// ]\nuser.mngr.dirtyProperties;\n\nuser.mngr.sync();\n\n//after the data has been synced, mngr.dirtyProperties will return an empty array again\n\n// returns:\n// []\nuser.mngr.dirtyProperties;\n```\n\n* mngr.sync(method, syncLocal) - send the local model data to the REST API to be synced\n\n```javascript\nvar userRepository = nagRestRepositoryFactory.create('user');\nvar user = userRepository.mngr.create();\n\nuser.mngr.extendData({\n  firstName: 'John',\n  lastName = 'Doe',\n  username = 'john.doe',\n  email = 'john.doe@example.com'\n});\n\n//the mngr.sync() method will send the data through the rest api to be processed (generally saved to a data\n//store of some sort).  the mngr.sync() method is smart enough to know what method to use.  since the\n//model's mngr.state is 'new', mngr.sync() will automatically use POST\n\n// POST /users with content of\n// {\n//   \"firstName\": \"John\"\n//   \"lastName\": \"Doe\",\n//   \"username\": \"john.doe\",\n//   \"email\": \"john.doe@example.com\"\n// }\nuser.mngr.sync();\n\n//now that the data is synced the model's mngr.state is marked as 'loaded' and if you try to\n//mngr.sync() again, it is going to PUT the data (or whatever is set and the update method for\n//the nagRestConfig service)\n\n// PUT /users/123 with content of\n// {\n//   \"id\": 123\n//   \"firstName\": \"John\"\n//   \"lastName\": \"Doe\",\n//   \"username\": \"john.doe\",\n//   \"email\": \"john.doe@example.com\"\n// }\nuser.mngr.sync();\n\n//the mngr.sync() method also allows you to specify the method to used to sync.  lets say I wanted to\n//update the email address however it would be a waste of bandwidth to have to send all the other data\n//since it is not changing.  luckily our rest api support the PATCH method and the mngr.sync() method is\n//smart enough to only send the dirty property when using the PATCH method\nuser.email = 'john.doe@example2.com';\n\n// PATCH /users/789 with content of\n// {\n//   \"email\": \"john.doe@example2.com\"\n// }\nuser.mngr.sync('PATCH');\n```\n\n* mngr.destroy() - sends a request to the REST API to delete the model\n\n```javascript\nvar userRepository = nagRestRepositoryFactory.create('user');\nvar user = userRepository.mngr.find(789);\n\n//to delete the user we can just call the mngr.destroy() method.  you should note the calling\n//mngr.destroy() only sends the delete call to the rest api, the model itself still has the data\n//so if you wanted (though you should never call mngr.destroy() unless you are sure), you could\n//sync the data back\n\n// DELETE /users/789\nuser.mngr.destroy();\n```\n\n* mngr.toJson() - convert the model's data to a simple JSON structure\n\n```javascript\nvar userRepository = nagRestRepositoryFactory.create('user');\nvar user = userRepository.mgnr.create();\n\nuser.set({\n  'firstName': 'John'\n  'lastName': 'Doe',\n  'username': 'john.doe',\n  'email': 'john.doe@example.com'\n});\n\n//the mngr.toJson() method returns a json object that represents the data the model is holding\n\n// results:\n// {\n//   \"firstName\": \"John\"\n//   \"lastName\": \"Doe\",\n//   \"username\": \"john.doe\",\n//   \"email\": \"john.doe@example.com\"\n// }\nvar jsonData = user.mngr.toJson();\n\n//also note that modifying the resulting JSON will not effect the models data\njsonData.firstName = 'John2';\n\n// returns:\n// 'John'\nuser.firstName;\n```\n\n* mngr.isRemote() - tells you whether or not the model in local only or a version of it is synced to the API.  mngr.isRemote() will return true even if the local version of the model is different from the remote version (mngr.state can tell you the specific state of the model if needed).\n\n```javascript\nvar userRepository = nagRestBaseRepository.create('user');\nvar user = userRepository.mngr.create();\n\n//since the model has not been synced to the rest api mngr.isRemote() method will return false\n\n// returns:\n// false\nuser.mngr.isRemote();\n\nvar remoteUser = userRepository.mngr.create({\n  id: 123,\n  firstName: 'John',\n  lastName: 'Doe'\n}, true);\n\n//since the model is created with the remoteFlag and the idProperty is set, mngrisRemote() will return\n//true\n\n// returns:\n// true\nremoteUser.mngr.isRemote();\n```\n\n* mngr.getRelation(relationName, relationId) - gets relational data for the model\n\n```javascript\nvar userRepository = nagRestRepositoryFactory.create('user');\nvar user = userRepository.mngr.find(123);\n\n//we can pull any relation thats configured in the relations part of the schema with the\n//mngr.getRelation() method.  the first parameter this method takes is the name of the relation\n//as it is defined in the schema.  so lets get all projects for a user.\n\n// GET /users/123/projects\nuser.mngr.getRelation('project').then(function(data) {\n  var projects = data.parsedData\n});\n\n//you can also pass in a second parameter that is the relation id value\n\n// GET /users/123/projects/234\nvar project = user.mngr.getRelation('project', 234);\n```\n\n* mngr.extendData(newData, setRemoteFlag) - This will allow you to set multiple properties at once by sending them as an object\n\n```javascript\nvar userRepository = nagRestRepositoryFactory.create('user');\nvar user = userRepository.mngr.create();\n\n//now instead of set each property individually, you can pass an object of property values to the\n//extendData method to set multiple values at once\nuser.mngr.extendData({\n  firstName: 'John',\n  lastName: 'Doe\n});\n\n// returns:\n// 'John';\nuser.firstName;\n\n// returns:\n// 'Doe'\nuser.lastName;\n```\n\n* mngr.route - returns the route of the model without the base url prepended (READ ONLY)\n* mngr.fullRoute - returns the same things as route but will the base url prepended (READ ONLY)\n\n```javascript\nvar userRepository = nagRestRepositoryFactory.create('user');\nvar user = userRepository.mngr.create();\n\n//by default it will result in the route for the schema of the model\n\n// returns:\n// '/users';\nuser.mngr.route\n\n//now if the mngr.isRemote() results in true (which just means the mngr.state is either 'loaded' or\n//'dirty'), it will include the idProperty of the model in the route\n\nvar remoteUser - userRepository.mngr.find(1);\n\n// returns:\n// '/users/1'\nremoteUser.mngr.route;\n\n//it also take into account the flattenItemRoute property of the schema configuration\n\nvar nestedUserRepository = nagRestRepositoryFactory.create('user', {\n  route: '/projects/1/users'\n  flattenItemRoute: true\n});\nvar nestedUser = nestedUserRepository.mngr.create();\n\n// returns:\n// '/projects/1/users'\nnestedUser.mngr.route;\n\nvar nestedRemoteUser = nestedUserRepository.mngr.find(1);\n\n// returns:\n// '/users/1';\nnestedRemoteUser.mngr.route;\n\n//fullRoute will just prepend the base url to the route.  lets assume the base url is\n//http://api.example.com\n\n// returns:\n// 'http://api.example.com/users/1'\nnestedRemoteUser.mngr.fullRoute;\n```\n\n* mngr.reset() - This will reset all dirty properties of the model to the original state before they were changed (will not work on models where the mngr.state is 'new' or 'deleted')\n\n```javascript\nvar userRepository = nagRestRepositoryFactory.create('user');\nvar user = userRepository.mngr.create({\n  id: 1,\n  firstName: 'John',\n  lastName: 'Doe'\n}, true);\n\n// returns:\n// 'John'\nuser.firstName;\n\nuser.firstName = 'John2';\n\n// returns:\n// 'John2'\nuser.firstName;\n\nuser.mngr.reset();\n\n// returns:\n// 'John';\nuser.firstName;\n```\n\n* mngr.schema - returns the schema related to this model (READ ONLY)\n\n## Object Definitions\n\n### Schema\n\n* **route (default: null)**\n  * The relatively route from the configured base url to this resource\n* **idProperty (default: nagRestConfig.getModelIdProperty())**\n  * The property that represents the id (generally a primary key in a database)\n* **properties: (default: {})**\n  * An object with the definition of all the valid properties for the resource where the key is the property name and the value is the property configuration.  Property configuration can be:\n    * sync: Tells when this property should be saved (NOTE: when doing a PUT sync, these values are ignored).  The value are:\n      * false - don't sync ever (can not set data)\n      * 'create' - only save on create (can only set data when model is not synced)\n      * 'update' - only save on update (con only set data when model is synced)\n    * remoteProperty: If you want the name of the property of the model to be different from the property that the remote api gives, give the remote property name here and it will normalize the property name both incoming and outgoing.\n* **relations**: This is an object where the key is the name of the resource and the value its configuration\n  * resource: The resourceName this relation links to\n  * flatten: Used to set the flattenItemRoute when retrieving models using getRelation().  if not set, flattenItemRoute will be set to the value of the flattenItemRoute of the resource schema the relation belongs to\n* **dataListLocation: (default: nagRestConfig.getResponseDataLocation())**\n  * A string representing the JSON hierarchy where the data in location in the REST API response when returning a list of resources\n* **dataItemLocation: (default: getResponseDataLocation())**\n  * A string representing the JSON hierarchy where the data in location in the REST API response when returning a single resource\n* **autoParse: (default: true)**\n  * Whether or not to automatically parse the REST API response\n* **requestFormatter: (default: nagRestConfig.getRequestFormatter())**\n  * A function that can wrap the model data in a specific format before sending it to the REST API.  This function take one parameter and that in the model data that is being sent.  The data passed into this callback has already been normalized to the proper format the REST API is expecting for the names of the property of the model.\n* **isArray**: (default: null)\n  * Determines whether all requests are or are not arrays when retrieving data.  This can be override on a call by call level with the forceIsArray() method on models/repositories\n* **flattenItemRoute**: (default: nagRestConfig.getFlattenItemRoute())\n  * if set to true, mngr.route/mngr.fullRoute will remove all but the last resource path. (```/users/123/projects/234/teams/345``` would be converted to ```/teams/345```).  This only applies to when there is a trailing id, if the trailing element in the url is a resource name, nothing will get removed (```/users/123/projects/234/teams``` would remain the same)\n",
  "readmeFilename": "README.md",
  "_id": "nucleus-angular-rest@0.3.2",
  "description": "This component of Nucleus Angular is designed to allow you to easily use a REST API within your AngularJS applications.  There are other libraries that serve a similar purpose to this one and the two I most commonly see referenced are:",
  "repository": {
    "type": "git",
    "url": "git://github.com/nucleus-angular/rest.git"
  }
}